<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<OPENROAD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<!-- Copyright (c) 2016 Actian Corporation. All Rights Reserved.-->
	<APPLICATION name="UnitTestFramework">
		<included_apps>
			<row>
				<appname>core</appname>
				<version>-1</version>
				<imgfilename>core.plb</imgfilename>
			</row>
			<row_class>inclapp</row_class>
		</included_apps>
		<procstart>runtests</procstart>
		<database_type>2</database_type>
	</APPLICATION>
	<COMPONENT name="_readme" xsi:type="scriptsource">
		<script>
			<![CDATA[Unit Test Framework for OpenROAD
================================

The framework is very simple, it consists of:
-	A set of a few user classes similar to JUnit (Test, TestCase, Assert, Error, etc.)
-	Two global variables (one to reference the error of the last "Exception", the other to reference the Assert object)
-	The 4GL procedure "executeTests" that invokes the "run" method on a test class passed

When developing tests for a certain feature the developer has to:
-	Create the test class(es)
	- Add a subclass of TestCase to the application containing the framework or include them from a separate application
	- Within the test class:
		- You create and implement test methods (name must start with "test")
			- Within the test* methods you execute the methods/procedures to be tested
			  and use the assertion methods (using the G_Assert global variable) to verify the results.
			  Example: G_Assert.assertEquals(expectedVarchar='krojo02', actualVarchar=CurSession.UserName, errortext = 'Wrong user!');
			  If any assertion is not fulfilled then an error will be "thrown" (like an exception).
		- You can override setUp() and tearDown() methods if required
		 (setup will run before any test method, teardown will run after all have completed)
		- You can skip a test by invoking the skipTest method (using the G_Assert global variable).
		  This can be done in either the setUp() method (which will skip all tests in the class) or in each test method.
-	Add other components needed within the test methods
	(e.g. for the XMLParserCallbacksTests I had to add the callback 4GL procedures and a 4GL procedure that calculates the memory size of the current process)
-	Create/edit a starting component (e.g. called "runtests"):
	- It should call the procedure executeTests for each test class. Pass an object of the test class in the "test" parameter.

Errors/Failures/Skipped are logged in the Trace file/window.
You can also run the application from command line and test the return status of the application
(1 indicates an error/failure, 0 means success, -1 indicates skipped tests, but otherwise ok).
This way I can easily add the tests to an automated test batch.
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="Assert" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[METHOD fail(
	errortext = varchar(2000) not null,
	errorline = integer not null,
	errorexec = varchar(100) not null	
)=
{
    G_Error = Error.Create();
    G_Error.errortext = errortext;
    G_Error.errorline = errorline;
    G_Error.errorexec = errorexec;
    EXIT;
}

METHOD throwAssertionFailedError(
	errortext = varchar(2000) not null,
	errorline = integer not null,
	errorexec = varchar(100) not null	
)=
{
    G_Error = AssertionFailedError.Create();
    G_Error.errortext = errortext;
    G_Error.errorline = errorline;
    G_Error.errorexec = errorexec;
    EXIT;
}

METHOD skipTest(
	errortext  = varchar(2000) not null
) =
declare
    p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
    G_Error = SkippedTest.Create();
    G_Error.errortext = errortext;
    G_Error.errorline = p.linenumber;
    G_Error.errorexec = p.Name;
    EXIT;
end

METHOD assertEquals (
  errortext = varchar(2000) not null;
  expectedInteger = Integer8 default null;
  actualInteger = Integer8 default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
  p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate <> actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger <> actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat <> actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney <> actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar <> actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertNotEquals (
  errortext = varchar(2000) not null;
  expectedInteger = Integer8 default null;
  actualInteger = Integer8 default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
  p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate = actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected not equals: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger = actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected not equals: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat = actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected not equals: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney = actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected not equals: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar = actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected not equals: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertLessThan (
  errortext = varchar(2000) not null;
  expectedInteger = Integer default null;
  actualInteger = Integer default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
   p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate <= actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less than: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger <= actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less than: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat <= actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less than: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney <= actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less than: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar <= actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less than: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertLessEquals (
  errortext = varchar(2000) not null;
  expectedInteger = Integer default null;
  actualInteger = Integer default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
   p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate < actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less or equals: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger < actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less or equals: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat < actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected  less or equals: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney < actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected  less or equals: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar < actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected less or equals: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertGreaterThan (
  errortext = varchar(2000) not null;
  expectedInteger = Integer default null;
  actualInteger = Integer default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
   p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate >= actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater than: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger >= actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater than: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat >= actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater than: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney >= actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater than: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar >= actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater than: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertGreaterEquals (
  errortext = varchar(2000) not null;
  expectedInteger = Integer default null;
  actualInteger = Integer default null;
  expectedFloat = Float default null;
  actualFloat = Float default null;
  expectedMoney = Float default null;
  actualMoney = Float default null;
  expectedDate = Date default null;
  actualDate = Date default null;
  expectedVarchar = varchar(4096) default null;
  actualVarchar = varchar(4096) default null;
) =
declare
   p = ProcExec DEFAULT NULL;
enddeclare
begin
  p = ProcExec(CurMethod.Parent);
  if expectedDate is not null then
    if expectedDate > actualDate then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater or equals: <' + ifnull(varchar(expectedDate), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualDate), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedInteger is not null then
    if expectedInteger > actualInteger then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater or equals: <' + ifnull(varchar(expectedInteger), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualInteger), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedFloat is not null then
    if expectedFloat > actualFloat then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected  greater or equals: <' + ifnull(varchar(expectedFloat), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualFloat), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedMoney is not null then
    if expectedMoney > actualMoney then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected  greater or equals: <' + ifnull(varchar(expectedMoney), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualMoney), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
  if expectedVarchar is not null then
    if expectedVarchar > actualVarchar then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected greater or equals: <' + ifnull(varchar(expectedVarchar), '<NULL>') + '>' +
		' actual: <' + ifnull(varchar(actualVarchar), '<NULL>') + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
  endif;
end

METHOD assertSame (
  errortext = varchar(2000) not null;
  expected = Object default null;
  actual = Object default null;
) =
declare
    p = ProcExec DEFAULT NULL;
enddeclare
begin
   p = ProcExec(CurMethod.Parent);
   if expected <> actual then
	if actual is null then
	    CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + varchar(expected.InstanceIdentifier) + '>' +
		' actual: <NULL>',
		errorline = p.linenumber,
		errorexec =  p.Name);
	else
	    CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <' + varchar(expected.InstanceIdentifier) + '>' +
		' actual: <' + varchar(actual.InstanceIdentifier) + '>',
		errorline = p.linenumber,
		errorexec =  p.Name);
	endif;
    endif;
end

METHOD assertNotSame (
	errortext = varchar(2000) not null;
	expected = Object default null;
	actual = Object default null;
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expected is null then
		if actual is null then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected is not: <NULL>' +
				' actual: <NULL>',
				errorline = p.linenumber,
				errorexec =  p.Name);
		endif;
	elseif actual is not null then
		if expected = actual then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected is not: <' + varchar(expected.InstanceIdentifier) + '>' +
			' actual: <' + varchar(actual.InstanceIdentifier) + '>',
			errorline = p.linenumber,
			errorexec =  p.Name);
		endif;
    endif;
end

METHOD assertNull (
  errortext = varchar(2000) not null;
  actual = Object default null;
) =
declare
    p = ProcExec DEFAULT NULL;
enddeclare
begin
   p = ProcExec(CurMethod.Parent);
   if actual IS NOT NULL then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <NULL> actual: ' + actual.ClassName,
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
end

METHOD assertNotNull (
  errortext = varchar(2000) not null;
  actual = Object default null;
) =
declare
    p = ProcExec DEFAULT NULL;
enddeclare
begin
   p = ProcExec(CurMethod.Parent);
   if actual IS NULL then
	CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
		'expected: <Object not null> actual: <NULL object>',
		errorline = p.linenumber,
		errorexec =  p.Name);
    endif;
end
]]>
		</script>
		<methods>
			<row>
				<displayname>fail</displayname>
			</row>
			<row>
				<displayname>throwAssertionFailedError</displayname>
			</row>
			<row>
				<displayname>assertequals</displayname>
			</row>
			<row>
				<displayname>assertnull</displayname>
			</row>
			<row>
				<displayname>assertsame</displayname>
			</row>
			<row>
				<displayname>assertnotnull</displayname>
			</row>
			<row>
				<displayname>assertlessthan</displayname>
			</row>
			<row>
				<displayname>assertgreaterthan</displayname>
			</row>
			<row>
				<displayname>assertgreaterequals</displayname>
			</row>
			<row>
				<displayname>assertlessequals</displayname>
			</row>
			<row>
				<displayname>assertnotsame</displayname>
			</row>
			<row>
				<displayname>assertnotequals</displayname>
			</row>
			<row>
				<displayname>skipTest</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="AssertionFailedError" xsi:type="classsource">
		<superclass>error</superclass>
	</COMPONENT>
	<COMPONENT name="Error" xsi:type="classsource">
		<superclass>userobject</superclass>
		<attributes>
			<row>
				<displayname>errortext</displayname>
				<datatype>varchar(2000)</datatype>
			</row>
			<row>
				<displayname>errorline</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>errorexec</displayname>
				<datatype>varchar(100)</datatype>
			</row>
			<row>
				<displayname>testmethod</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
	</COMPONENT>
	<COMPONENT name="executeTests" xsi:type="proc4glsource">
		<script>
			<![CDATA[procedure executeTests
(
	test = TestCase
)=
declare
	result = TestResult;
	i = INTEGER not null;
	t1 = INTEGER not null;
	t2 = INTEGER not null;
	e = Error DEFAULT NULL;
	resultstr = StringObject;
enddeclare
{
	CurProcedure.Trace(text= 'Running tests from ' + test.ClassName + ' ...');
	t1 = GetTickCount();
	test.run(result = result);
	t2 = GetTickCount();
	
	resultstr.Value = 
					test.ClassName +': TestsRun=' + varchar(result.TestsRun) + ', Time_in_ms=' + varchar(t2-t1) +
					', Failures=' + varchar(result.failures.LastRow) + ', Errors=' + varchar(result.errors.LastRow)+ 
					', Skipped=' + varchar(result.skipped.LastRow) + HC_NEWLINE;  

	IF result.skipped.LastRow>0 THEN
		CurSession.ExitCode=2;
		IF result.skipped.LastRow>0 THEN
			CurProcedure.Trace(text= '=== Skipped Tests ===');
		ENDIF;
		FOR i=1 TO result.skipped.LastRow DO
			e = result.skipped[i].error;
			CurProcedure.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
				HC_NEWLINE + HC_TAB + e.errortext);
		ENDFOR;		
	ENDIF;

	IF result.errors.LastRow>0 OR result.failures.LastRow>0 THEN
		CurSession.ExitCode=1;
		IF result.errors.LastRow>0 THEN
			CurProcedure.Trace(text= '=== Errors ===');
		ENDIF;
		FOR i=1 TO result.errors.LastRow DO
			e = result.errors[i].error;
			CurProcedure.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
			HC_NEWLINE +  e.ClassName + HC_NEWLINE + HC_TAB + e.errortext);
		ENDFOR;
		IF result.failures.LastRow>0 THEN
			CurProcedure.Trace(text= '=== Failures ===');
		ENDIF;
		FOR i=1 TO result.failures.LastRow DO
			e = result.failures[i].error;
			CurProcedure.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
			HC_NEWLINE + e.ClassName + HC_NEWLINE + HC_TAB + e.errortext);
		ENDFOR;
	ENDIF;

	resultstr.AppendToFile(filename=G_Helper.TestStatsFile);
	CurProcedure.Trace(text='======================================================================' + HC_NEWLINE +
		resultstr.Value + '======================================================================');
}
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="G_Assert" xsi:type="globsource">
		<datatype>assert</datatype>
	</COMPONENT>
	<COMPONENT name="G_Error" xsi:type="globsource">
		<datatype>error</datatype>
	</COMPONENT>
	<COMPONENT name="G_Helper" xsi:type="globsource">
		<datatype>helper</datatype>
	</COMPONENT>
	<COMPONENT name="GetTickCount" xsi:type="proc3glsource">
		<datatype>integer</datatype>
		<libraryname>kernel32.dll</libraryname>
	</COMPONENT>
	<COMPONENT name="Helper" xsi:type="classsource">
		<versshortremarks>
			<![CDATA[Helper functionality for tests]]>
		</versshortremarks>
		<superclass>userobject</superclass>
		<script>
			<![CDATA[INITIALIZE=
DECLARE
	testdir = VARCHAR(256) NOT NULL;
	tmpdir = VARCHAR(256) NOT NULL;
	teststatsfile = VARCHAR(256) NOT NULL;
ENDDECLARE
{
	IF CurSession.OperatingSystem=SY_UNIX THEN
		CurObject.DirectorySeparator = '/';
	ENDIF;

	testdir = CurSession.GetEnv(name = 'OR_UNITTEST_TESTDIR');
	IF testdir = '' THEN
		testdir = CurSession.WorkingDirectory;
	ENDIF;
	CurObject.TestDir = testdir;

	teststatsfile = CurSession.GetEnv(name = 'OR_UNITTEST_STATSFILE');
	IF teststatsfile = '' THEN
		teststatsfile = testdir + CurObject.DirectorySeparator + 'orunitteststats.log';
	ENDIF;
	CurObject.TestStatsFile = teststatsfile;

	tmpdir = CurSession.GetEnv(name = 'OR_UNITTEST_TMPDIR');
	IF tmpdir='' THEN
		IF CurSession.DirectoryExists(directory=testdir + CurObject.DirectorySeparator + 'temp')=TRUE THEN
			tmpdir = testdir + CurObject.DirectorySeparator + 'temp';
		ELSEIF CurSession.DirectoryExists(directory='testtemp')=TRUE THEN
			tmpdir = CurSession.WorkingDirectory + CurObject.DirectorySeparator + 'testtemp';
		ENDIF;
		IF tmpdir='' THEN
			tmpdir = CurSession.GetEnv(name = 'II_TEMPORARY');
			IF tmpdir='' THEN
				tmpdir = CurSession.GetEnv(name = 'TMPDIR');
				IF tmpdir='' THEN
					tmpdir = CurSession.GetEnv(name = 'TEMP');
					IF tmpdir='' THEN
						tmpdir = CurSession.GetEnv(name = 'TMP');
						IF tmpdir='' THEN
							IF CurSession.OperatingSystem=SY_UNIX THEN
								IF CurSession.DirectoryExists(directory='/tmp')=TRUE THEN
									tmpdir = '/tmp';
								ELSEIF CurSession.DirectoryExists(directory='/var/tmp')=TRUE THEN
									tmpdir = '/var/tmp';
								ELSEIF CurSession.DirectoryExists(directory='/usr/tmp')=TRUE THEN
									tmpdir = '/usr/tmp';
								ENDIF;
							ELSE
								IF CurSession.DirectoryExists(directory='C:\TEMP')=TRUE THEN
									tmpdir = 'C:\TEMP';
								ELSEIF CurSession.DirectoryExists(directory='C:\TMP')=TRUE THEN
									tmpdir = 'C:\TMP';
								ELSEIF CurSession.DirectoryExists(directory='\TEMP')=TRUE THEN
									tmpdir = '\TMP';
								ELSEIF CurSession.DirectoryExists(directory='\TEMP')=TRUE THEN
									tmpdir = '\TMP';
								ENDIF;
							ENDIF;
						ENDIF;
					ENDIF;
				ENDIF;
			ENDIF;
		ENDIF;
	ENDIF;
	IF tmpdir='' THEN
		CurObject.TempDir = CurSession.WorkingDirectory;
	ELSE
		CurObject.TempDir = tmpdir;
	ENDIF;

	tmpdir = CurSession.GetEnv(name = 'OR_UNITTEST_RESOURCEDIR');
	IF tmpdir='' THEN
		IF CurSession.DirectoryExists(directory=testdir + CurObject.DirectorySeparator + 'resources')=TRUE THEN
			tmpdir = testdir + CurObject.DirectorySeparator + 'resources';
		ENDIF;
		IF tmpdir='' THEN
			IF CurSession.DirectoryExists(directory='resources')=TRUE THEN
				tmpdir = CurSession.WorkingDirectory + CurObject.DirectorySeparator + 'resources';
			ENDIF;
		ENDIF;
	ENDIF;
	IF tmpdir='' THEN
		CurObject.ResourceDir = CurObject.TempDir;
	ELSE
		CurObject.ResourceDir = tmpdir;
	ENDIF;

	CurExec.Trace(text='WorkingDirectory=' + CurSession.WorkingDirectory);
	CurExec.Trace(text='TestDir=' + CurObject.TestDir);
	CurExec.Trace(text='TempDir=' + CurObject.TempDir);
	CurExec.Trace(text='ResourceDir=' + CurObject.ResourceDir);
}

METHOD LocalFilename(
	filename= VARCHAR(256) NOT NULL // OS-independent filename containing !
)=
DECLARE
	fname = VARCHAR(256) NOT NULL;
	lname = VARCHAR(256) NOT NULL;
	pos=integer NOT NULL;
	i = INTEGER NOT NULL;
	ln = INTEGER NOT NULL;
ENDDECLARE
{
    fname = filename;
	ln = LENGTH(fname);
	pos = LOCATE(fname, '!');
	WHILE pos<=ln DO
		lname = lname + LEFT(fname, pos-1) + CurObject.DirectorySeparator;
		fname = SHIFT(fname, -pos);
		pos = LOCATE(fname, '!');
	ENDWHILE;
	lname = lname + fname;
	RETURN lname;
}

METHOD GetResourceFilePath(
	filename= VARCHAR(256) NOT NULL
)=
{
	RETURN CurObject.ResourceDir + CurObject.DirectorySeparator + CurObject.LocalFilename(filename=filename);
}


METHOD GetTempFilePath(
	filename = VARCHAR(256) NOT NULL,
	register_name = SMALLINT NOT NULL
)=
DECLARE
	lname = VARCHAR(256) NOT NULL;
	str = StringObject DEFAULT NULL;
ENDDECLARE
{
	lname = CurObject.TempDir + CurObject.DirectorySeparator + CurObject.LocalFilename(filename=filename);
	IF register_name = TRUE THEN
		str = StringObject.Create();
		str.Value = lname;
		CurObject.htTempFiles.InsertObject(key = filename, object = str);
	ENDIF;
	RETURN lname;
}

METHOD RemoveRegisteredTempFile(
	filename = VARCHAR(256) NOT NULL
)=
DECLARE
	str = StringObject DEFAULT NULL;
	i = INTEGER NOT NULL;
ENDDECLARE
{
	str = StringObject(CurObject.htTempFiles.Find(key=filename));
	IF str IS NOT NULL THEN
		CurObject.RemoveFile(filename = str.Value);
		CurObject.htTempFiles.RemoveObject(key=filename);
	ENDIF;
}

METHOD RemoveRegisteredTempFiles()=
DECLARE
	arr = ARRAY OF HashTableEntry DEFAULT NULL;
	i = INTEGER NOT NULL;
ENDDECLARE
{
	arr = CurObject.htTempFiles.Entries;
	FOR i=arr.LastRow DOWNTO 1 DO
		CurObject.RemoveFile(filename = StringObject(arr[i].object).Value);
	ENDFOR;
	arr.Clear();
}

METHOD RemoveFile(
	filename= VARCHAR(256) NOT NULL
)=
DECLARE
	procwin = INTEGER NOT NULL;
	procwait = INTEGER NOT NULL;
	cmd = VARCHAR(2000) NOT NULL;
ENDDECLARE
{
	procwin = CurSession.ProcessWindow;
	procwait = CurSession.ProcessWait;
	CurSession.ProcessWindow = FALSE;
	CurSession.ProcessWait = TRUE;
	IF CurSession.FileExists(filename=filename)=FALSE THEN
		CurExec.Trace(text = 'File "'+filename+'" does not exist, cannot remove!');
		RETURN ER_FAIL;
	ENDIF;
	IF CurSession.OperatingSystem=SY_UNIX THEN
		cmd = 'rm -f '+filename;
	ELSE
		cmd = 'cmd /c del /f "'+filename+'"';
	ENDIF;
	CALL SYSTEM :cmd;
	CurSession.ProcessWindow = procwin;
	CurSession.ProcessWait = procwait;
	IF CurSession.FileExists(filename=filename)=TRUE THEN
		CurExec.Trace(text = 'Removal of file "'+filename+'" failed!');
		RETURN ER_FAIL;
	ENDIF;
}



]]>
		</script>
		<attributes>
			<row>
				<displayname>DirectorySeparator</displayname>
				<datatype>varchar(1)</datatype>
				<defaultvalue>3</defaultvalue>
				<defaultstring>
					<![CDATA[\]]>
				</defaultstring>
			</row>
			<row>
				<displayname>TempDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>htTempFiles</displayname>
				<datatype>stringhashtable</datatype>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>ResourceDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>TestDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>TestStatsFile</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>LocalFilename</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>GetResourceFilePath</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>GetTempFilePath</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>RemoveRegisteredTempFiles</displayname>
			</row>
			<row>
				<displayname>RemoveRegisteredTempFile</displayname>
			</row>
			<row>
				<displayname>RemoveFile</displayname>
				<datatype>integer</datatype>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="runtests" xsi:type="proc4glsource">
		<script>
			<![CDATA[procedure runtests() =
{
    CALLPROC executeTests(test = SampleTest.Create());
}
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="sampletest" xsi:type="classsource">
		<versshortremarks>
			<![CDATA[A sample test class]]>
		</versshortremarks>
		<superclass>testcase</superclass>
		<script>
			<![CDATA[METHOD testMethod1()=
{
    G_Assert.AssertEquals(expectedInteger=1 , actualInteger=1, errortext='Something wrong.');
}
]]>
		</script>
		<methods>
			<row>
				<displayname>testMethod1</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="SkippedTest" xsi:type="classsource">
		<superclass>error</superclass>
	</COMPONENT>
	<COMPONENT name="Test" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[METHOD run()=
{
    CurMethod.Trace(text = 'Virtual method invoked: Test.run()');
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>name</displayname>
				<datatype>varchar(100)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>run</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="Testcase" xsi:type="classsource">
		<superclass>test</superclass>
		<script>
			<![CDATA[INITIALIZE=
DECLARE
	getAppSource = PROCEDURE RETURNING AppSource;
ENDDECLARE

METHOD run(result=TestResult DEFAULT NULL)=
{
	IF (result IS NULL) THEN
		result = TestResult.Create();
	ENDIF;

	IF CurMethod.SetExitTrap()=ER_OK THEN
		// try
		result.StartTest(thetest=CurObject);
		CurMethod.Trace(text = 'Running setUp');
		CurObject.setUp();
		CurMethod.Trace(text = HC_TAB + '(OK)');
	ELSE // catch
		IF G_Error.IsA(class=SkippedTest)=TRUE THEN
			result.AddSkipped(thetest=CurObject, testmethod='setUp');
			CurMethod.Trace(text = HC_TAB + '(SKIPPED)');
		ELSEIF G_Error.IsA(class=AssertionFailedError)=TRUE THEN
			result.AddFailure(thetest=CurObject, testmethod='setUp');
			CurMethod.Trace(text = HC_TAB + '(FAILED)');
		ELSE
			result.AddError(thetest=CurObject, testmethod='setUp');
			CurMethod.Trace(text = HC_TAB + '(ERROR)');
		ENDIF;
		RETURN;
	ENDIF;

    CurObject.runTest(result=result); 
    CurObject.tearDown();
}

METHOD runTest(result=TestResult DEFAULT NULL)=
DECLARE
    cs = ClassSource DEFAULT NULL;
    i = INTEGER NOT NULL;
    k = INTEGER NOT NULL;
    methname = VARCHAR(32) NOT NULL;
    ucl = UserClassObject DEFAULT NULL;
    appsrc = AppSource DEFAULT NULL;
    marr = ARRAY OF StringObject;
ENDDECLARE
{
    ucl = UserClassObject(CurObject.Class);
    cs = ClassSource(ucl.ObjectSource);
    IF cs IS NULL THEN
        // ClassSource not found (class from image) - using workaround.
        appsrc = getAppSource();
        cs = ClassSource(appsrc.FetchComponent(componentname=ucl.FullName));
    ENDIF;
    FOR i=1 TO cs.Methods.LastRow DO
		methname = cs.Methods[i].Name;
		IF LOWERCASE(LEFT(methname, 4))='test' THEN
			k=k+1;
			marr[k].Value = methname;
		ENDIF;
    ENDFOR;
	marr.Sort(value = AS_ASC);
    FOR i=1 TO k DO
		methname = marr[i].Value;
		CurMethod.Trace(text = 'Running method ' + methname);
		IF CurMethod.SetExitTrap()=ER_OK THEN
			// try
			result.TestsRun=result.TestsRun+1;
			CurObject.:methname();
			CurMethod.Trace(text = HC_TAB + '(OK)');
		ELSE // catch
			IF G_Error.IsA(class=SkippedTest)=TRUE THEN
				result.AddSkipped(thetest=CurObject, testmethod=methname);
				CurMethod.Trace(text = HC_TAB + '(SKIPPED)');
			ELSEIF G_Error.IsA(class=AssertionFailedError)=TRUE THEN
				result.AddFailure(thetest=CurObject, testmethod=methname);
				CurMethod.Trace(text = HC_TAB + '(FAILED)');
			ELSE
				result.AddError(thetest=CurObject, testmethod=methname);
				CurMethod.Trace(text = HC_TAB + '(ERROR)');
			ENDIF;
		ENDIF;
    ENDFOR;
}

METHOD setUp()=
{
}

METHOD tearDown()=
{
}

PROCEDURE getAppSource()=
DECLARE
	pExec = ProcExec DEFAULT NULL;
ENDDECLARE
BEGIN
	pExec = ProcExec(CurProcedure.Parent);
	WHILE pExec.Parent IS NOT NULL DO
		IF pExec.Parent.IsA(class = ProcExec)=TRUE THEN
			pExec = ProcExec(pExec.Parent);
		ELSE
			ENDLOOP;
		ENDIF;
	ENDWHILE;
	
	RETURN pExec.ObjectSource.ParentApplication;
END;

]]>
		</script>
		<methods>
			<row>
				<displayname>run</displayname>
			</row>
			<row>
				<displayname>runTest</displayname>
				<isprivate>1</isprivate>
			</row>
			<row>
				<displayname>setUp</displayname>
				<isprivate>1</isprivate>
			</row>
			<row>
				<displayname>tearDown</displayname>
				<isprivate>1</isprivate>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="TestFailure" xsi:type="classsource">
		<superclass>userobject</superclass>
		<attributes>
			<row>
				<displayname>error</displayname>
				<datatype>error</datatype>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>test</displayname>
				<datatype>test</datatype>
				<isnullable>1</isnullable>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
	</COMPONENT>
	<COMPONENT name="TestResult" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[METHOD startTest(thetest = Test)=
{
    CurObject.TestsRun = CurObject.TestsRun+1;
}

METHOD AddFailure(thetest = Test, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Failures.LastRow+1;
    CurObject.Failures[i].test=thetest;
    CurObject.Failures[i].error=G_error;
    CurObject.Failures[i].error.testmethod = testmethod;
    
    G_error = NULL;
}

METHOD AddError(thetest = Test, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Errors.LastRow+1;
    CurObject.Errors[i].test=thetest;
    CurObject.Errors[i].error=G_error;
    CurObject.Errors[i].error.testmethod = testmethod;
    G_error = NULL;
}

METHOD AddSkipped(thetest = Test, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Skipped.LastRow+1;
    CurObject.Skipped[i].test=thetest;
    CurObject.Skipped[i].error=G_error;
    CurObject.Skipped[i].error.testmethod = testmethod;
    G_error = NULL;
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>TestsRun</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>errors</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>failures</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>skipped</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>startTest</displayname>
			</row>
			<row>
				<displayname>addError</displayname>
			</row>
			<row>
				<displayname>addFailure</displayname>
			</row>
			<row>
				<displayname>addSkipped</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
</OPENROAD>
