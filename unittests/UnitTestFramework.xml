<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<OPENROAD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<!-- Copyright (c) 2019 Actian Corporation. All Rights Reserved.-->
	<APPLICATION name="UnitTestFramework">
		<included_apps>
			<row>
				<appname>core</appname>
				<version>-1</version>
				<imgfilename>core.plb</imgfilename>
			</row>
			<row_class>inclapp</row_class>
		</included_apps>
		<procstart>runtests</procstart>
		<database_type>2</database_type>
	</APPLICATION>
	<COMPONENT name="Assert" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[/**
 * The Assert class provides a set of assert methods.
 * Messages are only displayed when an assert fails.
 *
 * @author	Bodo Bergmann
 */

INITIALIZE()=
DECLARE
	equalFloats = PROCEDURE RETURNING INTEGER NOT NULL;
	equalStrings = PROCEDURE RETURNING INTEGER NOT NULL;
	equalJSON = PROCEDURE RETURNING INTEGER NOT NULL;
ENDDECLARE

/**
 * Fails a test with the given errortext.
 *
 * @param errortext	The error text to be printed
 * @param errorline	The line where the error occured
 * @param errorexec	The name of the component where the error occured
 *
 */
METHOD fail(
	errortext = varchar(2000) not null,
	errorline = integer not null,
	errorexec = varchar(100) not null
)=
{
	G_Error = Error.Create();
	G_Error.errortext = errortext;
	G_Error.errorline = errorline;
	G_Error.errorexec = errorexec;
	EXIT;
}

/**
 * Throws an AssertionFailedError with the given errortext.
 *
 * @param errortext	The error text to be printed
 * @param errorline	The line where the error occured
 * @param errorexec	The name of the component where the error occured
 *
 */
METHOD throwAssertionFailedError(
	errortext = varchar(2000) not null,
	errorline = integer not null,
	errorexec = varchar(100) not null
)=
{
	G_Error = AssertionFailedError.Create();
	G_Error.errortext = errortext;
	G_Error.errorline = errorline;
	G_Error.errorexec = errorexec;
	EXIT;
}

/**
 * Skips a test with the given errortext.
 *
 * @param errortext	The text to be printed
 * @param errorline	The line where the skipping occured
 * @param errorexec	The name of the component where the skipping occured
 *
 */
METHOD skipTest(
	errortext	= varchar(2000) not null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	G_Error = SkippedTest.Create();
	G_Error.errortext = errortext;
	G_Error.errorline = p.linenumber;
	G_Error.errorexec = p.Name;
	EXIT;
end

/**
 * Asserts that two values are equal.
 * If they are not equal, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 * @param expectedString	The expected StringObject
 * @param actualString		The actual StringObject
 * @param expectedJSON		The expected StringObject containing JSON
 * @param actualJSON		The actual StringObject containing JSON
 * @param expectedJsonValue	The expected JsonValue
 * @param actualJsonValue	The actual JsonValue
 *
 */

METHOD assertEquals (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null,
	expectedString = stringobject default null,
	actualString = stringobject default null,
	expectedJSON = stringobject default null,
	actualJSON = stringobject default null,
	expectedJsonValue = JsonValue default null,
	actualJsonValue = JsonValue default null
) =
declare
	p = ProcExec DEFAULT NULL;
	jh = JsonHandler default null;
	j1	= Stringobject default null;
	j2	= Stringobject default null;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null then
		if actualInteger is null or expectedInteger <> actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null then
		if actualVarchar is null or expectedVarchar <> actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null then
		if actualFloat is null or equalFloats(f1=expectedFloat, f2=actualFloat)=FALSE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null then
		if actualMoney is null or expectedMoney <> actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null then
		if actualDate is null or expectedDate <> actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedString is not null then
		if equalStrings(s1=expectedString, s2=actualString)=FALSE then
			if CurObject.TraceStringsOnFailure=TRUE then
				CurMethod.Trace(text = HC_NEWLINE+'=== Expected string: ===');
				CurMethod.Trace(string = expectedString);
				CurMethod.Trace(text = HC_NEWLINE+'=== Actual string (not equal): ===');
				CurMethod.Trace(string = actualString);
			endif;
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertEquals: actualString does not match expectedString',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedJSON is not null then
		if equalJSON(json1=expectedJSON, json2=actualJSON)=FALSE then
			if CurObject.TraceStringsOnFailure=TRUE then
				CurMethod.Trace(text = HC_NEWLINE+'=== Expected JSON: ===');
				CurMethod.Trace(string = expectedJSON);
				CurMethod.Trace(text = HC_NEWLINE+'=== Actual JSON (not equal): ===');
				CurMethod.Trace(string = actualJSON);
			endif;
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertEquals: actualJSON does not match expectedJSON',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedJsonValue is not null then
		if actualJsonValue is null then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertEquals: actualJsonValue is NULL',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
		jh = CurSession.JsonHandler;
		j1 = stringobject.Create();
		j2 = stringobject.Create();
		jh.Write(value=expectedJsonValue, json=j1, sortobjectmembers=TRUE);
		jh.Write(value=actualJsonValue, json=j2, sortobjectmembers=TRUE);
		if equalJSON(json1=j1, json2=j2)=FALSE then
			if CurObject.TraceStringsOnFailure=TRUE then
				CurMethod.Trace(text = HC_NEWLINE+'=== Expected JsonValue: ===');
				CurMethod.Trace(string = j1);
				CurMethod.Trace(text = HC_NEWLINE+'=== Actual JsonValue (not equal): ===');
				CurMethod.Trace(string = j2);
			endif;
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertEquals: actualJsonValue does not match expectedJsonValue',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	else
		if actualInteger is not null
		or actualVarchar is not null
		or actualFloat is not null
		or actualMoney is not null
		or actualDate is not null
		or actualString is not null
		or actualJSON is not null
		or actualJsonValue is not null
		then
			CurObject.throwAssertionFailedError(errortext='Expected parameter is missing!',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	endif;
end

/**
 * Asserts that two values are not equal.
 * If they are equal, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertNotEquals (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null,
	expectedString = stringobject default null,
	actualString = stringobject default null,
	expectedJSON = stringobject default null,
	actualJSON = stringobject default null,
	expectedJsonValue = JsonValue default null,
	actualJsonValue = JsonValue default null
) =
declare
	p = ProcExec DEFAULT NULL;
	jh = JsonHandler default null;
	j1	= Stringobject default null;
	j2	= Stringobject default null;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null then
		if actualInteger is not null and expectedInteger = actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected not equals: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null then
		if actualVarchar is not null and expectedVarchar = actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected not equals: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null then
		if actualFloat is not null and equalFloats(f1=expectedFloat, f2=actualFloat)=TRUE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected not equals: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null then
		if actualMoney is not null and expectedMoney = actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected not equals: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null then
		if actualDate is not null and expectedDate = actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected not equals: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedString is not null then
		if equalStrings(s1=expectedString, s2=actualString)=TRUE then
			if CurObject.TraceStringsOnFailure=TRUE then
				CurMethod.Trace(text = HC_NEWLINE+'=== Actual/expected string (equal): ===');
				CurMethod.Trace(string = actualString);
			endif;
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertNotEquals: actualString is equal expectedString',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedJSON is not null then
		if equalJSON(json1=expectedJSON, json2=actualJSON)=TRUE then
			if CurObject.TraceStringsOnFailure=TRUE then
				CurMethod.Trace(text = HC_NEWLINE+'=== Actual/expected JSON (equal): ===');
				CurMethod.Trace(string = actualJSON);
			endif;
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'assertNotEquals: actualJSON is equal expectedJSON',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedJsonValue is not null then
		if actualJsonValue is not null then
			jh = CurSession.JsonHandler;
			j1 = stringobject.Create();
			j2 = stringobject.Create();
			jh.Write(value=expectedJsonValue, json=j1, sortobjectmembers=TRUE);
			jh.Write(value=actualJsonValue, json=j2, sortobjectmembers=TRUE);
			if equalJSON(json1=j1, json2=j2)=TRUE then
				if CurObject.TraceStringsOnFailure=TRUE then
					CurMethod.Trace(text = HC_NEWLINE+'=== Actual/expected JsonValue (equal): ===');
					CurMethod.Trace(string = j1);
				endif;
				CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
					'assertNotEquals: actualJsonValue is equal expectedJsonValue',
					errorline = p.linenumber,
					errorexec =	p.Name);
			endif;
		endif;
	else
		if actualInteger is null
		and actualVarchar is null
		and actualFloat is null
		and actualMoney is null
		and actualDate is null
		or actualString is null
		or actualJSON is null
		or actualJsonValue is null
		then
			CurObject.throwAssertionFailedError(errortext='Expected parameter is missing!',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	endif;
end

/**
 * Asserts that the actual value is less than the expected value.
 * If it is not, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertLessThan (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null and actualInteger is not null then
		if expectedInteger <= actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less than: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null and actualVarchar is not null then
		if expectedVarchar <= actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less than: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null and actualFloat is not null then
		if expectedFloat < actualFloat or equalFloats(f1=expectedFloat, f2=actualFloat)=TRUE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less than: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null and actualMoney is not null then
		if expectedMoney <= actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less than: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null and actualDate is not null then
		if expectedDate <= actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less than: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	else
		CurObject.throwAssertionFailedError(errortext='Invalid or missing parameters!',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * Asserts that the actual value is less than or equal the expected value.
 * If it is not, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertLessEquals (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null and actualInteger is not null then
		if expectedInteger < actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less or equals: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null and actualVarchar is not null then
		if expectedVarchar < actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less or equals: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null and actualFloat is not null then
		if expectedFloat < actualFloat and equalFloats(f1=expectedFloat, f2=actualFloat)=FALSE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less or equals: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null and actualMoney is not null then
		if expectedMoney < actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less or equals: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null and actualDate is not null then
		if expectedDate < actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected less or equals: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	else
		CurObject.throwAssertionFailedError(errortext='Invalid or missing parameters!',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * Asserts that the actual value is greater than the expected value.
 * If it is not, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertGreaterThan (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null and actualInteger is not null then
		if expectedInteger >= actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater than: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null and actualVarchar is not null then
		if expectedVarchar >= actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater than: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null and actualFloat is not null then
		if expectedFloat > actualFloat or equalFloats(f1=expectedFloat, f2=actualFloat)=TRUE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater than: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null and actualMoney is not null then
		if expectedMoney >= actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater than: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null and actualDate is not null then
		if expectedDate >= actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater than: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	else
		CurObject.throwAssertionFailedError(errortext='Invalid or missing parameters!',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * Asserts that the actual value is greater than or equal the expected value.
 * If it is not, an AssertionFailedError is thrown with the given errortext.
 * Apart from the "errortext" parameters exactly one pair of matching and non-null
 * "expected..." and "actual..." parameters for the same datatype should be passed.
 *
 * @param errortext		The error text to be printed
 * @param expectedInteger	The expected integer value
 * @param actualInteger		The actual integer value
 * @param expectedFloat		The expected flaot value
 * @param actualFloat		The actual float value
 * @param expectedMoney		The expected money value
 * @param actualMoney		The actual money value
 * @param expectedDate		The expected date value
 * @param actualDate		The actual date value
 * @param expectedVarchar	The expected varchar value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertGreaterEquals (
	errortext = varchar(2000) not null,
	expectedInteger = Integer8 default null,
	actualInteger = Integer8 default null,
	expectedFloat = Float default null,
	actualFloat = Float default null,
	expectedMoney = Money default null,
	actualMoney = Money default null,
	expectedDate = Date default null,
	actualDate = Date default null,
	expectedVarchar = varchar(4096) default null,
	actualVarchar = varchar(4096) default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expectedInteger is not null and actualInteger is not null then
		if expectedInteger > actualInteger then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater or equals: <' + ifnull(varchar(expectedInteger), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedVarchar is not null and actualVarchar is not null then
		if expectedVarchar > actualVarchar then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater or equals: <' + ifnull(varchar(expectedVarchar), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedFloat is not null and actualFloat is not null then
		if expectedFloat > actualFloat and equalFloats(f1=expectedFloat, f2=actualFloat)=FALSE then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater or equals: <' + float2txt(f=expectedFloat) + '>' +
				' actual: <' + float2txt(f=actualFloat) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedMoney is not null and actualMoney is not null then
		if expectedMoney > actualMoney then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater or equals: <' + ifnull(varchar(expectedMoney), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif expectedDate is not null and actualDate is not null then
		if expectedDate > actualDate then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected greater or equals: <' + ifnull(varchar(expectedDate), 'NULL') + '>' +
				' actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	else
		CurObject.throwAssertionFailedError(errortext='Invalid or missing parameters!',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * Asserts that two object references are referencing the same object.
 * If they are not, an AssertionFailedError is thrown with the given errortext.
 *
 * @param errortext	The error text to be printed
 * @param expected	The expected object reference
 * @param actual	The actual object reference
 *
 */
METHOD assertSame (
	errortext = varchar(2000) not null,
	expected = Object default null,
	actual = Object default null,
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expected <> actual then
		if actual is null then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + varchar(expected.InstanceIdentifier) + '>' +
				' actual: <NULL>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		else
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected: <' + varchar(expected.InstanceIdentifier) + '>' +
				' actual: <' + varchar(actual.InstanceIdentifier) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	endif;
end

/**
 * Asserts that two object references are not referencing the same object.
 * If they are referencing the same object, an AssertionFailedError is thrown with the given errortext.
 *
 * @param errortext	The error text to be printed
 * @param expected	The expected object reference
 * @param actual	The actual object reference
 *
 */
METHOD assertNotSame (
	errortext = varchar(2000) not null,
	expected = Object default null,
	actual = Object default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if expected is null then
		if actual is null then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected is not: <NULL>' +
				' actual: <NULL>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	elseif actual is not null then
		if expected = actual then
			CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
				'expected is not: <' + varchar(expected.InstanceIdentifier) + '>' +
				' actual: <' + varchar(actual.InstanceIdentifier) + '>',
				errorline = p.linenumber,
				errorexec =	p.Name);
		endif;
	endif;
end

/**
 * Asserts that an object reference or a variable is NULL.
 * If it is not, an AssertionFailedError is thrown with the given errortext.
 *
 * @param errortext	        The error text to be printed
 * @param actual	        The actual object reference
 * @param actualInteger		The actual integer value
 * @param actualFloat		The actual float value
 * @param actualMoney		The actual money value
 * @param actualDate		The actual date value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertNull (
	errortext = varchar(2000) not null,
	actual = Object default null,
	actualInteger = Integer8 default null,
	actualFloat = Float default null,
	actualMoney = Money default null,
	actualDate = Date default null,
	actualVarchar = varchar(4096) default null
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if actual IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL> actual: ' + actual.ClassName,
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualInteger IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL> actual: <' + ifnull(varchar(actualInteger), 'NULL') + '>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualFloat IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL> actual: <' + float2txt(f=actualFloat) + '>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualMoney IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL> actual: <' + ifnull(varchar(actualMoney), 'NULL') + '>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualDate IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL>actual: <' + ifnull(varchar(actualDate), 'NULL') + '>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualVarchar IS NOT NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <NULL> actual: <' + ifnull(varchar(actualVarchar), 'NULL') + '>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * Asserts that an object reference or a variable is not NULL.
 * If it is NULL, an AssertionFailedError is thrown with the given errortext.
 *
 * @param errortext	The error text to be printed
 * @param actual	The actual object reference
 * @param actualInteger		The actual integer value
 * @param actualFloat		The actual float value
 * @param actualMoney		The actual money value
 * @param actualDate		The actual date value
 * @param actualVarchar		The actual varchar value
 *
 */
METHOD assertNotNull (
	errortext = varchar(2000) not null,
	actual = Object,
	actualInteger = Integer8,
	actualFloat = Float,
	actualMoney = Money,
	actualDate = Date,
	actualVarchar = varchar(4096)
) =
declare
	p = ProcExec DEFAULT NULL;
enddeclare
begin
	p = ProcExec(CurMethod.Parent);
	if actual IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Object not null> actual: <NULL object>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualInteger IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Integer not null> actual: <NULL Integer>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualFloat IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Float not null> actual: <NULL Float>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualMoney IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Money not null> actual: <NULL Money>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualDate IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Date not null> actual: <NULL Date>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	elseif actualVarchar IS NULL then
		CurObject.throwAssertionFailedError(errortext=errortext+HC_NEWLINE+HC_TAB+
			'expected: <Varchar not null> actual: <NULL Varchar>',
			errorline = p.linenumber,
			errorexec =	p.Name);
	endif;
end

/**
 * The equalFloats() procedure compares two float values.
 * Two nearly equal IEEE floating-point values are considered as equal
 * if their text representations are equal.
 *
 * @param f1	The first float value to be compared
 * @param f2	The second float value to be compared
 * @return	TRUE if the two float values are considered to be equal, FALSE otherwise.
 *
 */
PROCEDURE equalFloats(
	f1 = float,
	f2 = float
)=
declare
	jn1 = JsonNumber;
	jn2 = JsonNumber;
enddeclare
{
	if f1 IS NULL THEN
		if f2 IS NULL THEN
			RETURN TRUE;
		else
			RETURN FALSE;
		endif;
	elseif f2 IS NULL THEN
		RETURN FALSE;
	endif;
	jn1.SetValue(value=f1);
	jn2.SetValue(value=f2);
	if jn1.TextValue=jn2.TextValue THEN
		RETURN TRUE;
	else
		RETURN FALSE;
	endif;
}

PROCEDURE equalStrings(
	s1 = stringobject default null,
	s2 = stringobject default null,
)=
declare
	i = integer not null default 1;
	v1 = varchar(16000) not null;
	v2 = varchar(16000) not null;
enddeclare
{
	IF s1 IS NULL THEN
		IF s2 IS NULL THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		ENDIF;
	ELSEIF s2 IS NULL THEN
		RETURN FALSE;
	ENDIF;

	IF s1.Length <> s2.Length THEN
		RETURN FALSE;
	ENDIF;

	// Now compare the strings - they could be larger than 2000 byte
	// therefore we cannot use the Value attribute.
	// Use 4000 character chunks - Note: A UTF8 character can take up to 4 bytes
	WHILE i<=s1.Length DO
		v1 = s1.substring(startposition=i, length=4000);
		v2 = s2.substring(startposition=i, length=4000);
		if v1<>v2 THEN
			RETURN FALSE;
		ENDIF;
		i=i+4000;
	ENDWHILE;
	RETURN TRUE;
}

PROCEDURE equalJSON(
	json1 = stringobject default null,
	json2 = stringobject default null,
)=
declare
	jv1 = JsonValue default null;
	jv2 = JsonValue default null;
	jh = JsonHandler default null;
	json1a	= Stringobject;
	json2a	= Stringobject;
enddeclare
{
	IF json1 IS NULL THEN
		IF json2 IS NULL THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		ENDIF;
	ELSEIF json2 IS NULL THEN
		RETURN FALSE;
	ENDIF;
	jh = CurSession.JsonHandler;
	jv1 = jh.Parse(json = json1);
	IF jv1 IS NULL THEN
		CurProcedure.Trace(text = jh.Errortext);
		RETURN FALSE;
	ENDIF;
	jh.Write(value=jv1, json=json1a, sortobjectmembers=TRUE);

	jv2 = jh.Parse(json = json2);
	IF jv2 IS NULL THEN
		CurProcedure.Trace(text = jh.Errortext);
		RETURN FALSE;
	ENDIF;
	jh.Write(value=jv2, json=json2a, sortobjectmembers=TRUE);
	RETURN equalStrings(s1=json1a, s2=json2a);
}

]]>
		</script>
		<attributes>
			<row>
				<displayname>TraceStringsOnFailure</displayname>
				<datatype>smallint</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>fail</displayname>
			</row>
			<row>
				<displayname>throwAssertionFailedError</displayname>
			</row>
			<row>
				<displayname>assertequals</displayname>
			</row>
			<row>
				<displayname>assertnull</displayname>
			</row>
			<row>
				<displayname>assertsame</displayname>
			</row>
			<row>
				<displayname>assertnotnull</displayname>
			</row>
			<row>
				<displayname>assertlessthan</displayname>
			</row>
			<row>
				<displayname>assertgreaterthan</displayname>
			</row>
			<row>
				<displayname>assertgreaterequals</displayname>
			</row>
			<row>
				<displayname>assertlessequals</displayname>
			</row>
			<row>
				<displayname>assertnotsame</displayname>
			</row>
			<row>
				<displayname>assertnotequals</displayname>
			</row>
			<row>
				<displayname>skipTest</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="AssertionFailedError" xsi:type="classsource">
		<superclass>error</superclass>
	</COMPONENT>
	<COMPONENT name="Error" xsi:type="classsource">
		<superclass>userobject</superclass>
		<attributes>
			<row>
				<displayname>errortext</displayname>
				<datatype>varchar(2000)</datatype>
			</row>
			<row>
				<displayname>errorline</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>errorexec</displayname>
				<datatype>varchar(100)</datatype>
			</row>
			<row>
				<displayname>testmethod</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
	</COMPONENT>
	<COMPONENT name="executeTests" xsi:type="proc4glsource">
		<script>
			<![CDATA[/**
 * The executeTests procedure adds a test to the test suite (G_Helper.AppTestSuite) which will be run in a separate thread.
 *
 * @author	Bodo Bergmann
 *
 * @param test	The testcase to be added
 *
 */
PROCEDURE executeTests
(
	test = TestCase DEFAULT NULL
)=
{
	G_Helper.AddTestToRun(test = test);
}
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="float2txt" xsi:type="proc4glsource">
		<versshortremarks>
			<![CDATA[Converts float value to text - length depending on value]]>
		</versshortremarks>
		<script>
			<![CDATA[/**
 * The float2txt procedure converts a float value to text and returns it.
 * The length of the returned text depends on the value - there are no trailing zeros.
 *
 *
 * @author	Bodo Bergmann
 *
 * @param f	The float value to be converted
 * @return	The text representing the float value (with decimal point - independent of II_DECIMAL)
 *		The text is 'NULL' for a null float value.
 *
 */

PROCEDURE float2txt(f = float)=
declare
    jn = JsonNumber;
enddeclare
{
    if f IS NULL THEN
      return 'NULL';
    endif;
    jn.SetValue(value=f);
    RETURN jn.TextValue;
}
]]>
		</script>
		<datatype>varchar(20)</datatype>
	</COMPONENT>
	<COMPONENT name="G_Assert" xsi:type="globsource">
		<datatype>assert</datatype>
	</COMPONENT>
	<COMPONENT name="G_Error" xsi:type="globsource">
		<datatype>error</datatype>
	</COMPONENT>
	<COMPONENT name="G_Helper" xsi:type="globsource">
		<datatype>helper</datatype>
	</COMPONENT>
	<COMPONENT name="GetTickCount" xsi:type="proc3glsource">
		<datatype>integer</datatype>
		<libraryname>kernel32.dll</libraryname>
	</COMPONENT>
	<COMPONENT name="Helper" xsi:type="classsource">
		<versshortremarks>
			<![CDATA[Helper functionality for tests]]>
		</versshortremarks>
		<superclass>userobject</superclass>
		<script>
			<![CDATA[/**
 * The Helper class provides a set of helper attributes and methods,
 * which can be used via the G_Helper global variable (instance of Helper class).
 * Messages are only displayed when an assert fails.
 *
 * @author	Bodo Bergmann
 *
 */
 
INITIALIZE=
DECLARE
	testdir = VARCHAR(256) NOT NULL;
	tmpdir = VARCHAR(256) NOT NULL;
	teststatsfile = VARCHAR(256) NOT NULL;
	xd = XmlDocument;
	valid_rootelem = SMALLINT NOT NULL;
ENDDECLARE
{
	IF CurSession.OperatingSystem=SY_UNIX THEN
		CurObject.DirectorySeparator = '/';
	ENDIF;

	testdir = CurSession.GetEnv(name = 'OR_UNITTEST_TESTDIR');
	IF testdir = '' THEN
		testdir = CurSession.WorkingDirectory;
	ENDIF;
	CurObject.TestDir = testdir;

	teststatsfile = CurSession.GetEnv(name = 'OR_UNITTEST_STATSFILE');
	IF teststatsfile = '' THEN
		teststatsfile = testdir + CurObject.DirectorySeparator + 'orunitteststats.log';
	ENDIF;
	CurObject.TestStatsFile = teststatsfile;

	teststatsfile = CurSession.GetEnv(name = 'OR_UNITTEST_GEN_XML_STATS');
	IF LOWERCASE(teststatsfile) = 'true' THEN
		CurObject.genXmlStats = TRUE;
		teststatsfile = CurSession.GetEnv(name = 'OR_UNITTEST_STATSFILE_XML');
		IF teststatsfile = '' THEN
			teststatsfile = testdir + CurObject.DirectorySeparator + 'orunitteststats.xml';
		ENDIF;
		CurObject.TestStatsFileXml = teststatsfile;
		IF CurSession.FileExists(filename = teststatsfile)=TRUE THEN
			IF xd.ParseUrl(urllocation = teststatsfile)=ER_OK THEN
				IF xd.RootElement.Name = 'testsuites' THEN
					valid_rootelem = TRUE;
				ENDIF;
			ENDIF;
		ENDIF;
		IF valid_rootelem = FALSE THEN
			xd.RootElement = XmlElement.Create();
			xd.RootElement.Name = 'testsuites';
		ENDIF;
		CurObject.TestStatsXmlDoc = xd;
	ENDIF;

	tmpdir = CurSession.GetEnv(name = 'OR_UNITTEST_TMPDIR');
	IF tmpdir='' THEN
		IF CurSession.DirectoryExists(directory=testdir + CurObject.DirectorySeparator + 'temp')=TRUE THEN
			tmpdir = testdir + CurObject.DirectorySeparator + 'temp';
		ELSEIF CurSession.DirectoryExists(directory='testtemp')=TRUE THEN
			tmpdir = CurSession.WorkingDirectory + CurObject.DirectorySeparator + 'testtemp';
		ENDIF;
		IF tmpdir='' THEN
			tmpdir = CurSession.GetEnv(name = 'II_TEMPORARY');
			IF tmpdir='' THEN
				tmpdir = CurSession.GetEnv(name = 'TMPDIR');
				IF tmpdir='' THEN
					tmpdir = CurSession.GetEnv(name = 'TEMP');
					IF tmpdir='' THEN
						tmpdir = CurSession.GetEnv(name = 'TMP');
						IF tmpdir='' THEN
							IF CurSession.OperatingSystem=SY_UNIX THEN
								IF CurSession.DirectoryExists(directory='/tmp')=TRUE THEN
									tmpdir = '/tmp';
								ELSEIF CurSession.DirectoryExists(directory='/var/tmp')=TRUE THEN
									tmpdir = '/var/tmp';
								ELSEIF CurSession.DirectoryExists(directory='/usr/tmp')=TRUE THEN
									tmpdir = '/usr/tmp';
								ENDIF;
							ELSE
								IF CurSession.DirectoryExists(directory='C:\TEMP')=TRUE THEN
									tmpdir = 'C:\TEMP';
								ELSEIF CurSession.DirectoryExists(directory='C:\TMP')=TRUE THEN
									tmpdir = 'C:\TMP';
								ELSEIF CurSession.DirectoryExists(directory='\TEMP')=TRUE THEN
									tmpdir = '\TMP';
								ELSEIF CurSession.DirectoryExists(directory='\TEMP')=TRUE THEN
									tmpdir = '\TMP';
								ENDIF;
							ENDIF;
						ENDIF;
					ENDIF;
				ENDIF;
			ENDIF;
		ENDIF;
	ENDIF;
	IF tmpdir='' THEN
		CurObject.TempDir = CurSession.WorkingDirectory;
	ELSE
		CurObject.TempDir = tmpdir;
	ENDIF;

	tmpdir = CurSession.GetEnv(name = 'OR_UNITTEST_RESOURCEDIR');
	IF tmpdir='' THEN
		IF CurSession.DirectoryExists(directory=testdir + CurObject.DirectorySeparator + 'resources')=TRUE THEN
			tmpdir = testdir + CurObject.DirectorySeparator + 'resources';
		ENDIF;
		IF tmpdir='' THEN
			IF CurSession.DirectoryExists(directory='resources')=TRUE THEN
				tmpdir = CurSession.WorkingDirectory + CurObject.DirectorySeparator + 'resources';
			ENDIF;
		ENDIF;
	ENDIF;
	IF tmpdir='' THEN
		CurObject.ResourceDir = CurObject.TempDir;
	ELSE
		CurObject.ResourceDir = tmpdir;
	ENDIF;

	CurExec.Trace(text='WorkingDirectory=' + CurSession.WorkingDirectory);
	CurExec.Trace(text='TestDir=' + CurObject.TestDir);
	CurExec.Trace(text='TempDir=' + CurObject.TempDir);
	CurExec.Trace(text='ResourceDir=' + CurObject.ResourceDir);
}


/**
 * Returns a file name in local (OS specific) format created from a
 * filename in portable format (using "!" directory separator).
 *
 * @param filename	OS-independent filename containing the "!" directory separator
 * @return		The filename in local format
 *
 */
METHOD LocalFilename(
	filename= VARCHAR(256) NOT NULL
)=
DECLARE
	fname = VARCHAR(256) NOT NULL;
	lname = VARCHAR(256) NOT NULL;
	pos=integer NOT NULL;
	i = INTEGER NOT NULL;
	ln = INTEGER NOT NULL;
ENDDECLARE
{
	fname = filename;
	ln = LENGTH(fname);
	pos = LOCATE(fname, '!');
	WHILE pos<=ln DO
		lname = lname + LEFT(fname, pos-1) + CurObject.DirectorySeparator;
		fname = SHIFT(fname, -pos);
		pos = LOCATE(fname, '!');
	ENDWHILE;
	lname = lname + fname;
	RETURN lname;
}

/**
 * Returns a file path in the ResourceDir created from a
 * filename in portable format (using "!" directory separator).
 *
 * @param filename	OS-independent filename containing the "!" directory separator
 * @return		The filename in local format
 *
 */
METHOD GetResourceFilePath(
	filename= VARCHAR(256) NOT NULL
)=
{
	RETURN CurObject.ResourceDir + CurObject.DirectorySeparator + CurObject.LocalFilename(filename=filename);
}

/**
 * Returns a file path in the TempDir created from a
 * filename in portable format (using "!" directory separator).
 *
 * @param filename	OS-independent filename containing the "!" directory separator
 * @param register_name	Specifies if the filename should be registered for deletion using RemoveRegisteredTempFile() or RemoveRegisteredTempFiles()
 * @return		The filename in local format
 *
 */
METHOD GetTempFilePath(
	filename = VARCHAR(256) NOT NULL,
	register_name = SMALLINT NOT NULL
)=
DECLARE
	lname = VARCHAR(256) NOT NULL;
	str = StringObject DEFAULT NULL;
ENDDECLARE
{
	lname = CurObject.TempDir + CurObject.DirectorySeparator + CurObject.LocalFilename(filename=filename);
	IF register_name = TRUE THEN
		str = StringObject.Create();
		str.Value = lname;
		CurObject.htTempFiles.InsertObject(key = filename, object = str);
	ENDIF;
	RETURN lname;
}

/**
 * Removes a registered file with filename in portable format
 *
 * @param filename	OS-independent filename containing the "!" directory separator
 *
 */
METHOD RemoveRegisteredTempFile(
	filename = VARCHAR(256) NOT NULL
)=
DECLARE
	str = StringObject DEFAULT NULL;
	i = INTEGER NOT NULL;
ENDDECLARE
{
	str = StringObject(CurObject.htTempFiles.Find(key=filename));
	IF str IS NOT NULL THEN
		CurObject.RemoveFile(filename = str.Value);
		CurObject.htTempFiles.RemoveObject(key=filename);
	ENDIF;
}

/**
 * Removes all registered files
 *
 */
METHOD RemoveRegisteredTempFiles()=
DECLARE
	arr = ARRAY OF HashTableEntry DEFAULT NULL;
	i = INTEGER NOT NULL;
ENDDECLARE
{
	arr = CurObject.htTempFiles.Entries;
	FOR i=arr.LastRow DOWNTO 1 DO
		CurObject.RemoveFile(filename = StringObject(arr[i].object).Value);
	ENDFOR;
	CurObject.htTempFiles.Clear();
	arr.Clear();
}

/**
 * Removes a file with filename in local (OS specific) format
 *
 * @param filename	OS specific filename
 * @return	status - ER_OK if successful, ER_FAIL otherwise
 *
 */
METHOD RemoveFile(
	filename= VARCHAR(256) NOT NULL
)=
DECLARE
	procwin = INTEGER NOT NULL;
	procwait = INTEGER NOT NULL;
	cmd = VARCHAR(2000) NOT NULL;
ENDDECLARE
{
	procwin = CurSession.ProcessWindow;
	procwait = CurSession.ProcessWait;
	CurSession.ProcessWindow = FALSE;
	CurSession.ProcessWait = TRUE;
	IF CurSession.FileExists(filename=filename)=FALSE THEN
		CurExec.Trace(text = 'File "'+filename+'" does not exist, cannot remove!');
		RETURN ER_FAIL;
	ENDIF;
	IF CurSession.OperatingSystem=SY_UNIX THEN
		cmd = 'rm -f '+filename;
	ELSE
		cmd = 'cmd /c del /f "'+filename+'"';
	ENDIF;
	CALL SYSTEM :cmd;
	CurSession.ProcessWindow = procwin;
	CurSession.ProcessWait = procwait;
	IF CurSession.FileExists(filename=filename)=TRUE THEN
		CurExec.Trace(text = 'Removal of file "'+filename+'" failed!');
		RETURN ER_FAIL;
	ENDIF;
	RETURN ER_OK;
}

/**
 * Returns a AppSource for the top component of the current thread.
 *
 * @return		The AppSource for the top component of the current thread
 *
 */
METHOD GetTestAppSource()=
DECLARE
	pExec = ProcExec DEFAULT NULL;
ENDDECLARE
BEGIN
	IF CurObject.TestAppSource IS NULL THEN
		pExec = ProcExec(CurMethod.Parent);
		WHILE pExec.Parent IS NOT NULL DO
			IF pExec.Parent.IsA(class = ProcExec)=TRUE THEN
				pExec = ProcExec(pExec.Parent);
			ELSE
				ENDLOOP;
			ENDIF;
		ENDWHILE;
		
		CurObject.TestAppSource = pExec.ObjectSource.ParentApplication;
	ENDIF;
	RETURN CurObject.TestAppSource;
END;


/**
 * Sets AppTestSuite and TestRunnerExec attributes to NULL.
 *
 *
 */
METHOD CleanupTestRunner()=
{
	CurObject.AppTestSuite = NULL;
	CurObject.TestRunnerExec = NULL;

}

/**
 * Adds a test to the test suite referenced the AppTestSuite attribute,
 * .
 * If TestRunnerExec attribute is NULL, then the AppTestSuite is created before
 * and a TestRunnerGhost, which will later run the test suite, is started as new thread
 * via openframe and its GhostExec assigned to the TestRunnerExec attribute.
 *
 * @param test	The test case to be added
 *
 */
METHOD AddTestToRun(test = TestCase DEFAULT NULL)=
{
	IF test IS NULL THEN
		CurExec.Trace(text = 'ERROR: Parameter "test" must not be NULL!');
		RETURN;
	ENDIF;
	IF CurObject.TestRunnerExec IS NULL THEN
		CurObject.AppTestSuite = TestSuite.Create();
		CurObject.AppTestSuite.Name = CurObject.GetTestAppSource().Name;		
		CurObject.TestRunnerExec = OPENFRAME TestRunnerGhost WITH ParentFrame=NULL;
	ENDIF;
	// Add the test to the TestSuite - will be run by the TestRunnerGhost thread
	CurObject.AppTestSuite.tests[CurObject.AppTestSuite.tests.LastRow+1] = test;
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>DirectorySeparator</displayname>
				<datatype>varchar(1)</datatype>
				<defaultvalue>3</defaultvalue>
				<defaultstring>
					<![CDATA[\]]>
				</defaultstring>
			</row>
			<row>
				<displayname>TempDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>htTempFiles</displayname>
				<datatype>stringhashtable</datatype>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>ResourceDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>TestDir</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>TestStatsFile</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>genXmlStats</displayname>
				<datatype>smallint</datatype>
			</row>
			<row>
				<displayname>TestStatsFileXml</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>TestStatsXmlDoc</displayname>
				<datatype>xmldocument</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row>
				<displayname>TestAppSource</displayname>
				<datatype>appsource</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row>
				<displayname>TestRunnerExec</displayname>
				<datatype>ghostexec</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row>
				<displayname>AppTestSuite</displayname>
				<datatype>testsuite</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>LocalFilename</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>GetResourceFilePath</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>GetTempFilePath</displayname>
				<datatype>varchar(256)</datatype>
			</row>
			<row>
				<displayname>RemoveRegisteredTempFiles</displayname>
			</row>
			<row>
				<displayname>RemoveRegisteredTempFile</displayname>
			</row>
			<row>
				<displayname>RemoveFile</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>GetTestAppSource</displayname>
				<datatype>appsource</datatype>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>AddTestToRun</displayname>
			</row>
			<row>
				<displayname>CleanupTestRunner</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="i_TestStatus" xsi:type="scriptsource">
		<script>
			<![CDATA[#define $OK 0
#define $FAILED 1
#define $SKIPPED 2
#define $ERROR 3
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="runtests" xsi:type="proc4glsource">
		<script>
			<![CDATA[/**
 * The runtests procedure is calling the executeTests procedure for each testcase class to be tested.
 * This procedure is provided here for demo purpose only (using the SampleTest class).
 *
 * @author	Bodo Bergmann
 *
 *
 */
procedure runtests() =
{
    CALLPROC executeTests(test = SampleTest.Create());
}
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="sampletest" xsi:type="classsource">
		<versshortremarks>
			<![CDATA[A sample test class]]>
		</versshortremarks>
		<superclass>testcase</superclass>
		<script>
			<![CDATA[/**
 * The sampletest class is a TestCase subclass with only one test method testMethod1.
 * It is provided here for demo purpose only.
 *
 * @author	Bodo Bergmann
 */

METHOD testMethod1()=
{
    G_Assert.AssertEquals(expectedInteger=1 , actualInteger=1, errortext='Something wrong.');
}
]]>
		</script>
		<methods>
			<row>
				<displayname>testMethod1</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="SkippedTest" xsi:type="classsource">
		<superclass>error</superclass>
	</COMPONENT>
	<COMPONENT name="Test" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[/**
 * The Test class is an abstract class.
 * It defines attributes and methods common to its subclasses (Testcase, Testsuite).
 *
 * Attributes:
 *	name	The name of the test.
 * Methods:
 * 	run	Runs the test. This method should be overridden by all subclasses.
 *
 * @author	Bodo Bergmann
 */

METHOD run()=
{
    CurMethod.Trace(text = 'Virtual method invoked: Test.run()');
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>name</displayname>
				<datatype>varchar(100)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>run</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="Testcase" xsi:type="classsource">
		<superclass>test</superclass>
		<script>
			<![CDATA[/**
 * The TestCase class represents a test case.
 * A test case defines the fixture to run multiple tests. To define a test case
 * 1) Implement a subclass of TestCase
 *	Add test methods (method name starts with "test"), which can use the assertion
 *	methods defined in the Assert class via the G_Assert global variables.
 * 2) Define instance variables that store the state of the fixture
 * 3) Initialize the fixture state by overriding setUp
 * 4) Clean-up after by overriding tearDown.
 *
 * @author	Bodo Bergmann
 *
 */

#include i_TestStatus
INITIALIZE=
DECLARE
	cs = ClassSource DEFAULT NULL;
	ucl = UserClassObject DEFAULT NULL;
	stat = INTEGER NOT NULL;
ENDDECLARE
{
	ucl = UserClassObject(CurObject.Class);
	cs = ClassSource(ucl.ObjectSource);
}

/**
 * The run() method runs the test case and collects the results in a TestResult object.
 * It will invoke setUp(), then run the test methods by invoking runTests(), then invoke tearDown().
 *
 * @param result	The TestResult object that captures the result of the test run.
 *
 */
METHOD run(result=TestResult DEFAULT NULL)=
{
	IF (result IS NULL) THEN
		result = TestResult.Create();
	ENDIF;

	result.StartTest(thetest=CurObject);

	result.StartTestMethod(thetest=CurObject, testmethod='setUp');
	IF CurMethod.SetExitTrap()=ER_OK THEN
		// try
		CurObject.setUp();
		result.EndTestMethod(status = $OK);
	ELSE // catch
		IF G_Error.IsA(class=SkippedTest)=TRUE THEN
			stat = $SKIPPED;
		ELSE // Error/Failure in setUp is always considered as Error
			stat = $ERROR;
		ENDIF;
		result.EndTestMethod(status = stat);
		RETURN; // Do not run any test methods if setUp was not OK
	ENDIF;

	CurObject.runTest(result=result); 
	CurObject.tearDown();
	result.EndTest();
}

/**
 * The runTests() method invokes all defined test methods (name starting with "test") of the class.
 * The methods are executed in alphabetic order.
 *
 * @param result	The TestResult object that captures the result of the test methods invoked.
 *
 */
METHOD runTest(result=TestResult DEFAULT NULL)=
DECLARE
	i = INTEGER NOT NULL;
	k = INTEGER NOT NULL;
	methname = VARCHAR(32) NOT NULL;
	marr = ARRAY OF StringObject;
	status = INTEGER NOT NULL;
ENDDECLARE
{
	IF cs IS NULL THEN
		// ClassSource not found (class from image) - using workaround.
		cs = ClassSource(G_Helper.GetTestAppSource().FetchComponent(componentname=ucl.FullName));
	ENDIF;
	FOR i=1 TO cs.Methods.LastRow DO
		methname = cs.Methods[i].Name;
		IF LOWERCASE(LEFT(methname, 4))='test' THEN
			k=k+1;
			marr[k].Value = methname;
		ENDIF;
	ENDFOR;
	marr.Sort(value = AS_ASC);
	FOR i=1 TO k DO
		methname = marr[i].Value;
		result.StartTestMethod(thetest=CurObject, testmethod=methname);
		IF CurMethod.SetExitTrap()=ER_OK THEN
			// try
			CurObject.:methname();
			stat = $OK;
		ELSE // catch
			IF G_Error.IsA(class=SkippedTest)=TRUE THEN
				stat = $SKIPPED;
			ELSEIF G_Error.IsA(class=AssertionFailedError)=TRUE THEN
				stat = $FAILED;
			ELSE
				stat = $ERROR;
			ENDIF;
		ENDIF;
		result.EndTestMethod(status = stat);
	ENDFOR;
}

/**
 *	The setUp() method can be overridden by subclasses to setup the test case.
 */
METHOD setUp()=
{
}

/**
 *	The tearDown() method can be overridden by subclasses to clean-up the test case.
 */
METHOD tearDown()=
{
}
]]>
		</script>
		<methods>
			<row>
				<displayname>run</displayname>
			</row>
			<row>
				<displayname>runTest</displayname>
				<isprivate>1</isprivate>
			</row>
			<row>
				<displayname>setUp</displayname>
				<isprivate>1</isprivate>
			</row>
			<row>
				<displayname>tearDown</displayname>
				<isprivate>1</isprivate>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="TestFailure" xsi:type="classsource">
		<superclass>userobject</superclass>
		<attributes>
			<row>
				<displayname>error</displayname>
				<datatype>error</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row>
				<displayname>test</displayname>
				<datatype>testcase</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
	</COMPONENT>
	<COMPONENT name="TestMethodResult" xsi:type="classsource">
		<superclass>userobject</superclass>
		<attributes>
			<row>
				<displayname>testclassname</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row>
				<displayname>testmethodname</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row>
				<displayname>status</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>exec_time</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>err</displayname>
				<datatype>error</datatype>
				<isnullable>1</isnullable>
				<defaultvalue>2</defaultvalue>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
	</COMPONENT>
	<COMPONENT name="TestResult" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[/**
 * The TestResult class represents the results of running a TestCase.
 *
 * @author	Bodo Bergmann
 *
 */
#include i_TestStatus
INITIALIZE=
DECLARE
	tmr = TestMethodResult DEFAULT NULL;
	curtest = Test DEFAULT NULL;
ENDDECLARE

/**
 * The startTest() method collects information before starting a test case.
 *
 * @param thetest	The Testcase being started.
 *
 */
METHOD startTest(thetest = Testcase)=
{
	CurMethod.Trace(text = HC_NEWLINE + 'Running tests from ' + thetest.ClassName + ' ...');
	CurObject.testclassname = thetest.classname;
	CurObject.testTimestamp = DATE('NOW');
	CurObject.exec_time = GetTickCount();
}

/**
 * The endTest() method collects information after ending a test case.
 *
 */
METHOD endTest()=
{
	CurObject.exec_time = GetTickCount() - CurObject.exec_time;
}

/**
 * The StartTestMethod() method collects information before invoking a test method.
 *
 * @param thetest	The Testcase being started.
 * @param testmethod	The name of the test method being invoked
 *
 */
METHOD StartTestMethod(thetest = Testcase, testmethod = varchar(32) not null)=
{
	CurMethod.Trace(text = 'Running method ' + testmethod);
	curtest = thetest;
	CurObject.TestsRun = CurObject.TestsRun+1;
	tmr = TestMethodResult.Create();
	tmr.testclassname = thetest.classname;
	tmr.testmethodname = testmethod;
	CurObject.testmethodresults[CurObject.testmethodresults.LastRow+1] = tmr;
	tmr.exec_time = GetTickCount();
}

/**
 * The EndTestMethod() method collects information after a test method has finished.
 *
 * @param status	The method execution status.
 *
 */
METHOD EndTestMethod(status = INTEGER NOT NULL)=
{
	tmr.exec_time = GetTickCount() - tmr.exec_time;
	tmr.status = status;
	tmr.err = G_error;
	CASE status OF
		$OK, DEFAULT: {
			CurMethod.Trace(text = HC_TAB + '(OK)');
		}
		$SKIPPED: {
			CurMethod.Trace(text = HC_TAB + '(SKIPPED)');
			CurObject.AddSkipped(thetest=curtest, testmethod=tmr.testmethodname);
		}
		$FAILED: {
			CurMethod.Trace(text = HC_TAB + '(FAILED)');
			CurObject.AddFailure(thetest=curtest, testmethod=tmr.testmethodname);
		}
		$ERROR: {
			CurObject.AddError(thetest=curtest, testmethod=tmr.testmethodname);
			CurMethod.Trace(text = HC_TAB + '(ERROR)');
		}
	ENDCASE;
}

/**
 * The AddFailure() method adds a row to the Failures array.
 *
 * @param thetest	The Testcase involved.
 * @param testmethod	The name of the test method involved
 *
 */
METHOD AddFailure(thetest = Testcase, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Failures.LastRow+1;
    CurObject.Failures[i].test=thetest;
    CurObject.Failures[i].error=G_error;
    CurObject.Failures[i].error.testmethod = testmethod;
    
    G_error = NULL;
}

/**
 * The AddError() method adds a row to the Errors array.
 *
 * @param thetest	The Testcase involved.
 * @param testmethod	The name of the test method involved
 *
 */
METHOD AddError(thetest = Testcase, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Errors.LastRow+1;
    CurObject.Errors[i].test=thetest;
    CurObject.Errors[i].error=G_error;
    CurObject.Errors[i].error.testmethod = testmethod;
    G_error = NULL;
}

/**
 * The AddSkipped() method adds a row to the Skipped array.
 *
 * @param thetest	The Testcase involved.
 * @param testmethod	The name of the test method involved
 *
 */
METHOD AddSkipped(thetest = Testcase, testmethod = varchar(32) not null)=
DECLARE
    i=INTEGER NOT NULL;
ENDDECLARE
{
    i = CurObject.Skipped.LastRow+1;
    CurObject.Skipped[i].test=thetest;
    CurObject.Skipped[i].error=G_error;
    CurObject.Skipped[i].error.testmethod = testmethod;
    G_error = NULL;
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>TestsRun</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>errors</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>failures</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>skipped</displayname>
				<datatype>testfailure</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>testmethodresults</displayname>
				<datatype>testmethodresult</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>testtimestamp</displayname>
				<datatype>date</datatype>
			</row>
			<row>
				<displayname>exec_time</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>testclassname</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>startTest</displayname>
			</row>
			<row>
				<displayname>addError</displayname>
			</row>
			<row>
				<displayname>addFailure</displayname>
			</row>
			<row>
				<displayname>addSkipped</displayname>
			</row>
			<row>
				<displayname>startTestMethod</displayname>
			</row>
			<row>
				<displayname>endTestMethod</displayname>
			</row>
			<row>
				<displayname>endTest</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="TestRunnerGhost" xsi:type="ghostsource">
		<script>
			<![CDATA[/**
 * The TestRunnerGhost frame runs the TestSuite G_Helper.AppTestSuite.
 * It also writes out the results/statictics of the run to the configured output file.
 * See environment variables: OR_UNITTEST_STATSFILE, OR_UNITTEST_STATSFILE_XML and OR_UNITTEST_GEN_XML_STATS
 *
 * @author	Bodo Bergmann
 *
 */
INITIALIZE() =
{
	// The UserEvent ensures that the caller can populate the TestSuite after the OPENFRAME statement.
	// The UserEvent block will be executed after the current event block in the calling thread has been finished,
	// unless there is a blocking statement in the calling thread (which should be prevented).
	CurFrame.SendUserEvent(eventname = 'RunTests');
}

ON USEREVENT 'RunTests' =
DECLARE
	tsresult = TestSuiteResult;
	resultstr = StringObject DEFAULT NULL;
	resultxml = XmlElement DEFAULT NULL;
ENDDECLARE
{
	G_Helper.AppTestSuite.run(result = tsresult);
	// Output test stats
	IF G_Helper.TestStatsXmlDoc IS NULL THEN
		resultstr = tsresult.AsString();
 		CurExec.Trace(text='======================================================================' + HC_NEWLINE +
			resultstr.Value + '======================================================================');
		resultstr.AppendToFile(filename=G_Helper.TestStatsFile);		
	ELSE // XML output
		resultxml = tsresult.AsXml();
		G_Helper.TestStatsXmlDoc.RootElement.AddChild(child = resultxml);
		G_Helper.TestStatsXmlDoc.WriteToFile(filename = G_Helper.TestStatsFileXml, indent=TRUE, standalone=TRUE);
 	ENDIF;

	// After running all tests make sure the frame and thus the application terminates.
	G_Helper.CleanupTestRunner();
	RETURN;
}
]]>
		</script>
	</COMPONENT>
	<COMPONENT name="Testsuite" xsi:type="classsource">
		<superclass>test</superclass>
		<script>
			<![CDATA[/**
 * A TestSuite is a collection of test cases.
 * When running the TestSuite all test cases are run and the results are collected in a TestSuiteResult object.
 *
 * @author	Bodo Bergmann
 *
 */

/**
 * The run() method runs all the test cases in the testsuite and collects the results in a TestSuiteResult object.
 *
 * @param result	The TestResult object that captures the result of the test run.
 *
 */
METHOD run(
	result = TestSuiteResult
)=
DECLARE
	results = ARRAY OF TestResult;
	i = INTEGER NOT NULL;
	t1 = INTEGER not null;
	t2 = INTEGER not null;
ENDDECLARE
{
	IF CurObject.Name = '' THEN
		CurObject.Name = G_Helper.GetTestAppSource().Name;
	ENDIF;
	CurExec.Trace(text= HC_NEWLINE + 'Running testsuite ' + CurObject.Name + ' ...');
	result.testsuitename = CurObject.Name;
	results = result.testresults;
	// Preparing test results
	FOR i=1 TO CurObject.tests.LastRow DO
		results[i] = TestResult.Create();
	ENDFOR;
	// Running tests
	result.testtimestamp = DATE('NOW');
	t1 = GetTickCount();
	FOR i=1 TO CurObject.tests.LastRow DO
		CurObject.tests[i].run(result = results[i]);
	ENDFOR;
	t2 = GetTickCount();
	result.exec_time = t2-t1;
	CurExec.Trace(text= HC_NEWLINE + 'TestSuite ' + CurObject.Name + ' DONE.');
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>tests</displayname>
				<datatype>testcase</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>run</displayname>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
	<COMPONENT name="TestSuiteResult" xsi:type="classsource">
		<superclass>userobject</superclass>
		<script>
			<![CDATA[/**
 * The TestSuiteResult class represents the results of running a TestSuite.
 *
 * @author	Bodo Bergmann
 *
 */
#include i_TestStatus

/**
 * The AsString() method returns a string representation of the test results.
 *
 * @return	StringObject
 *
 */
METHOD AsString()=
DECLARE
	i = INTEGER NOT NULL;
	tc = INTEGER NOT NULL;
	sum_cnt = INTEGER NOT NULL;
	sum_fail = INTEGER NOT NULL;
	sum_err = INTEGER NOT NULL;
	sum_skip = INTEGER NOT NULL;
	resultstr = StringObject;
	result = TestResult DEFAULT NULL;
	e = Error DEFAULT NULL;
ENDDECLARE
{
	FOR tc=1 TO CurObject.testresults.LastRow DO
		result = CurObject.testresults[tc];
		IF result.skipped.LastRow>0 THEN
			IF CurSession.ExitCode=0 THEN
				CurSession.ExitCode=2;
			ENDIF;
			IF result.skipped.LastRow>0 THEN
				CurExec.Trace(text= '=== Skipped Tests ===');
			ENDIF;
			FOR i=1 TO result.skipped.LastRow DO
				e = result.skipped[i].error;
				CurExec.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
					HC_NEWLINE + HC_TAB + e.errortext);
			ENDFOR;		
		ENDIF;

		IF result.errors.LastRow>0 OR result.failures.LastRow>0 THEN
			CurSession.ExitCode=1;
			IF result.errors.LastRow>0 THEN
				CurExec.Trace(text= '=== Errors ===');
			ENDIF;
			FOR i=1 TO result.errors.LastRow DO
				e = result.errors[i].error;
				CurExec.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
				HC_NEWLINE +  e.ClassName + HC_NEWLINE + HC_TAB + e.errortext);
			ENDFOR;
			IF result.failures.LastRow>0 THEN
				CurExec.Trace(text= '=== Failures ===');
			ENDIF;
			FOR i=1 TO result.failures.LastRow DO
				e = result.failures[i].error;
				CurExec.Trace(text= e.testmethod + ' ' + e.errorexec + ' (line '+varchar(e.errorline)+'): ' +
				HC_NEWLINE + e.ClassName + HC_NEWLINE + HC_TAB + e.errortext);
			ENDFOR;
		ENDIF;
		resultstr.ConcatVarchar(text = result.testclassName +': TestsRun=' + varchar(result.TestsRun) + 
			', Time_in_ms=' + varchar(result.exec_time) +
			', Failures=' + varchar(result.failures.LastRow) +
			', Errors=' + varchar(result.errors.LastRow) + 
			', Skipped=' + varchar(result.skipped.LastRow) + HC_NEWLINE);

		sum_cnt = sum_cnt + result.TestsRun;
		sum_fail = sum_fail + result.failures.LastRow;
		sum_err = sum_err + result.errors.LastRow;
		sum_skip = sum_skip + result.skipped.LastRow;
		
	ENDFOR;
	resultstr.ConcatVarchar(text = 'SUMMARY FOR TESTSUITE ' + CurObject.TestSuiteName + ': ' +
			'TestsRun=' + varchar(sum_cnt) + 
			', Time_in_ms=' + varchar(CurObject.exec_time) +
			', Failures=' + varchar(sum_fail) +
			', Errors=' + varchar(sum_err) + 
			', Skipped=' + varchar(sum_skip) + HC_NEWLINE);
	RETURN resultstr;
}

/**
 * The AsString() method returns an XML representation of the test results.
 *
 * @return	XMLElement
 *
 */
METHOD AsXML()=
DECLARE
	i = INTEGER NOT NULL;
	tc = INTEGER NOT NULL;
	tmc = INTEGER NOT NULL;
	sum_cnt = INTEGER NOT NULL;
	sum_fail = INTEGER NOT NULL;
	sum_err = INTEGER NOT NULL;
	sum_skip = INTEGER NOT NULL;
	resultstr = StringObject;
	result = TestResult DEFAULT NULL;
	tmr = TestMethodResult DEFAULT NULL;
	e = Error DEFAULT NULL;
	ts_elem = XMLElement;
	tm_elem = XMLElement DEFAULT NULL;
	sub_elem = XMLElement DEFAULT NULL;
	jn = JsonNumber;
	js = JsonString DEFAULT NULL;
ENDDECLARE
{
	ts_elem.Name = 'testsuite';
	ts_elem.AddAttribute(name = 'name', value = CurObject.TestSuiteName);
	jn.SetValue(value = float8(CurObject.exec_time)/1000.0);
	ts_elem.AddAttribute(name = 'time', value = jn.TextValue);
	js = JsonString(CurSession.JsonHandler.NewJsonValue(value = CurObject.testtimestamp));
	ts_elem.AddAttribute(name = 'timestamp', value = js.Value.Value);


	FOR tc=1 TO CurObject.testresults.LastRow DO
		result = CurObject.testresults[tc];
		IF result.skipped.LastRow>0 THEN
			IF CurSession.ExitCode=0 THEN
				CurSession.ExitCode=2;
			ENDIF;
		ENDIF;
		IF result.errors.LastRow>0 OR result.failures.LastRow>0 THEN
			CurSession.ExitCode=1;
		ENDIF;

		sum_cnt = sum_cnt + result.TestsRun;
		sum_fail = sum_fail + result.failures.LastRow;
		sum_err = sum_err + result.errors.LastRow;
		sum_skip = sum_skip + result.skipped.LastRow;

		FOR tmc=1 TO result.testmethodresults.LastRow DO
			tmr = result.testmethodresults[tmc];
			ts_elem.AddChildElement(name = 'testcase', child = BYREF(tm_elem));
			tm_elem.AddAttribute(name = 'name', value = tmr.testmethodname);
			tm_elem.AddAttribute(name = 'classname', value = CurObject.TestSuiteName + '.' + tmr.testclassname);
			jn.SetValue(value = float8(tmr.exec_time)/1000.0);
			tm_elem.AddAttribute(name = 'time', value = jn.TextValue);
			CASE tmr.status OF
				$OK, DEFAULT: ;
				$SKIPPED: {
					tm_elem.AddChildElement(name = 'skipped');
				}
				$FAILED: {
					tm_elem.AddChildElement(name = 'failure', child = BYREF(sub_elem));
					sub_elem.AddAttribute(name = 'message', value = tmr.err.errortext + ' (line: '+varchar(tmr.err.errorline)+')');
					sub_elem.AddAttribute(name = 'type', value = tmr.err.classname);
				}
				$ERROR: {
					tm_elem.AddChildElement(name = 'error', child = BYREF(sub_elem));
					sub_elem.AddAttribute(name = 'message', value = tmr.err.errortext + ' (line: '+varchar(tmr.err.errorline)+')');
					sub_elem.AddAttribute(name = 'type', value = tmr.err.classname);
				}
			ENDCASE;
		ENDFOR;
	ENDFOR;
	ts_elem.AddAttribute(name = 'tests', value = VARCHAR(sum_cnt));
	ts_elem.AddAttribute(name = 'errors', value = VARCHAR(sum_err));
	ts_elem.AddAttribute(name = 'failures', value = VARCHAR(sum_fail));
	ts_elem.AddAttribute(name = 'skipped', value = VARCHAR(sum_skip));

	RETURN ts_elem;
}
]]>
		</script>
		<attributes>
			<row>
				<displayname>testresults</displayname>
				<datatype>testresult</datatype>
				<isarray>1</isarray>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>testtimestamp</displayname>
				<datatype>date</datatype>
			</row>
			<row>
				<displayname>exec_time</displayname>
				<datatype>integer</datatype>
			</row>
			<row>
				<displayname>testsuitename</displayname>
				<datatype>varchar(32)</datatype>
			</row>
			<row_class>attributeobject</row_class>
		</attributes>
		<methods>
			<row>
				<displayname>AsString</displayname>
				<datatype>stringobject</datatype>
				<isnullable>1</isnullable>
			</row>
			<row>
				<displayname>AsXml</displayname>
				<datatype>xmlelement</datatype>
				<isnullable>1</isnullable>
			</row>
			<row_class>methodobject</row_class>
		</methods>
	</COMPONENT>
</OPENROAD>
